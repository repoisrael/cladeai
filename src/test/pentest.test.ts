import { describe, it, expect, beforeEach } from 'vitest';
import { supabase } from '@/integrations/supabase/client';
import {
  sanitizeHtml,
  sanitizeText,
  sanitizeUrl,
  detectSqlInjection,
  sanitizeSearchQuery,
  validateContent,
  validateUsername,
  validateEmail,
} from '@/lib/security';

/**
 * PENETRATION TESTING SUITE
 * Tests security vulnerabilities: XSS, SQL Injection, CSRF, Auth Bypass
 */

describe('Security Penetration Tests', () => {
  describe('XSS Attack Prevention', () => {
    it('should sanitize script tags in post content', () => {
      const xssPayload = '<script>alert("XSS")</script>Hello';
      const sanitized = sanitizeHtml(xssPayload);
      
      expect(sanitized).not.toContain('<script>');
      expect(sanitized).not.toContain('alert');
      expect(sanitized).toContain('Hello');
    });

    it('should sanitize event handler attributes', () => {
      const xssPayload = '<img src=x onerror="alert(\'XSS\')">';
      const sanitized = sanitizeHtml(xssPayload);
      
      expect(sanitized).not.toContain('onerror');
      expect(sanitized).not.toContain('alert');
    });

    it('should sanitize iframe injection', () => {
      const xssPayload = '<iframe src="javascript:alert(\'XSS\')"></iframe>';
      const sanitized = sanitizeHtml(xssPayload);
      
      expect(sanitized).not.toContain('<iframe>');
      expect(sanitized).not.toContain('javascript:');
    });

    it('should sanitize SVG-based XSS', () => {
      const xssPayload = '<svg onload="alert(\'XSS\')"><circle r="10"/></svg>';
      const sanitized = sanitizeHtml(xssPayload);
      
      expect(sanitized).not.toContain('onload');
      expect(sanitized).not.toContain('alert');
    });

    it('should strip ALL tags from usernames', () => {
      const maliciousUsername = 'user<script>alert("XSS")</script>';
      const sanitized = sanitizeText(maliciousUsername);
      
      expect(sanitized).toBe('useralert("XSS")');
      expect(sanitized).not.toContain('<');
      expect(sanitized).not.toContain('>');
    });

    it('should block javascript: URLs', () => {
      const maliciousUrl = 'javascript:alert("XSS")';
      const sanitized = sanitizeUrl(maliciousUrl);
      
      expect(sanitized).toBe('');
    });

    it('should block data: URLs', () => {
      const maliciousUrl = 'data:text/html,<script>alert("XSS")</script>';
      const sanitized = sanitizeUrl(maliciousUrl);
      
      expect(sanitized).toBe('');
    });

    it('should allow safe URLs', () => {
      expect(sanitizeUrl('https://example.com')).toBe('https://example.com');
      expect(sanitizeUrl('/relative/path')).toBe('/relative/path');
      expect(sanitizeUrl('mailto:test@example.com')).toBe('mailto:test@example.com');
    });
  });

  describe('SQL Injection Prevention', () => {
    it('should detect DROP TABLE attempts', () => {
      const maliciousQuery = "'; DROP TABLE users; --";
      expect(detectSqlInjection(maliciousQuery)).toBe(true);
    });

    it('should detect UNION SELECT attacks', () => {
      const maliciousQuery = "' UNION SELECT * FROM users --";
      expect(detectSqlInjection(maliciousQuery)).toBe(true);
    });

    it('should detect OR 1=1 attacks', () => {
      const maliciousQuery = "admin' OR '1'='1";
      expect(detectSqlInjection(maliciousQuery)).toBe(true);
    });

    it('should detect comment-based injection', () => {
      const maliciousQuery = "admin'; --";
      expect(detectSqlInjection(maliciousQuery)).toBe(true);
    });

    it('should sanitize search queries', () => {
      const maliciousSearch = "test'; DROP TABLE users; --";
      const sanitized = sanitizeSearchQuery(maliciousSearch);
      
      expect(sanitized).toBe('');
    });

    it('should allow safe search queries', () => {
      const safeQuery = "John's favorite song";
      const sanitized = sanitizeSearchQuery(safeQuery);
      
      expect(sanitized).toContain('John');
      expect(sanitized).toContain('favorite');
    });

    it('should prevent SQL injection via Supabase (parameterized queries)', async () => {
      // Supabase uses parameterized queries by default
      const maliciousInput = "'; DROP TABLE users; --";
      
      const { error } = await supabase
        .from('profiles')
        .select('*')
        .eq('username', maliciousInput)
        .limit(1);
      
      // Should not throw error, just return no results
      expect(error).toBeNull();
    });
  });

  describe('Input Validation', () => {
    it('should reject invalid usernames', () => {
      expect(validateUsername('ab').valid).toBe(false); // Too short
      expect(validateUsername('a'.repeat(31)).valid).toBe(false); // Too long
      expect(validateUsername('user@123').valid).toBe(false); // Invalid chars
      expect(validateUsername('user name').valid).toBe(false); // Spaces
      expect(validateUsername('user<script>').valid).toBe(false); // XSS attempt
    });

    it('should accept valid usernames', () => {
      expect(validateUsername('john_doe').valid).toBe(true);
      expect(validateUsername('user-123').valid).toBe(true);
      expect(validateUsername('Artist2024').valid).toBe(true);
    });

    it('should reject invalid emails', () => {
      expect(validateEmail('notanemail').valid).toBe(false);
      expect(validateEmail('missing@domain').valid).toBe(false);
      expect(validateEmail('@nodomain.com').valid).toBe(false);
      expect(validateEmail('spaces in@email.com').valid).toBe(false);
    });

    it('should accept valid emails', () => {
      expect(validateEmail('test@example.com').valid).toBe(true);
      expect(validateEmail('user+tag@domain.co.uk').valid).toBe(true);
    });

    it('should reject empty content', () => {
      expect(validateContent('').valid).toBe(false);
      expect(validateContent('   ').valid).toBe(false);
    });

    it('should reject overly long content', () => {
      const longContent = 'x'.repeat(10001);
      expect(validateContent(longContent).valid).toBe(false);
    });

    it('should reject spam-like content (excessive special chars)', () => {
      const spamContent = '!!!###$$$%%%^^^&&&***((()))';
      expect(validateContent(spamContent).valid).toBe(false);
    });

    it('should accept normal content', () => {
      const normalContent = 'This is a normal post with some punctuation!';
      expect(validateContent(normalContent).valid).toBe(true);
    });
  });

  describe('Authentication Bypass Attempts', () => {
    it('should reject unauthorized access to protected routes', async () => {
      // Sign out first
      await supabase.auth.signOut();
      
      // Try to access user-specific data
      const { data, error } = await supabase
        .from('user_interactions')
        .select('*')
        .limit(1);
      
      // Should fail due to RLS
      expect(error).toBeTruthy();
      expect(data).toBeNull();
    });

    it('should prevent accessing other users\' data', async () => {
      // Create two test users
      const user1 = await supabase.auth.signUp({
        email: 'pentest1@example.com',
        password: 'SecurePass123!',
      });
      
      const user2 = await supabase.auth.signUp({
        email: 'pentest2@example.com',
        password: 'SecurePass123!',
      });
      
      if (!user1.data.user || !user2.data.user) {
        return; // Skip if signup fails
      }
      
      // Sign in as user1
      await supabase.auth.signInWithPassword({
        email: 'pentest1@example.com',
        password: 'SecurePass123!',
      });
      
      // Try to access user2's interactions
      const { data, error } = await supabase
        .from('user_interactions')
        .select('*')
        .eq('user_id', user2.data.user.id)
        .limit(1);
      
      // Should return empty or error due to RLS
      expect(data?.length || 0).toBe(0);
    });

    it('should prevent privilege escalation (user to admin)', async () => {
      // Try to insert into profiles with admin role
      const { error } = await supabase
        .from('profiles')
        .update({ role: 'admin' })
        .eq('id', 'fake-user-id');
      
      // Should fail if RLS is configured properly
      expect(error).toBeTruthy();
    });
  });

  describe('Rate Limiting Tests', () => {
    it('should enforce rate limits on voting', async () => {
      const testPostId = 'test-post-id';
      let rateLimitError = null;
      
      // Try to vote 150 times rapidly
      for (let i = 0; i < 150; i++) {
        const { error } = await supabase
          .from('forum_votes')
          .upsert({
            post_id: testPostId,
            vote_type: 'up',
          });
        
        if (error && error.message.includes('rate limit')) {
          rateLimitError = error;
          break;
        }
      }
      
      // Should hit rate limit (100 votes per 5 min)
      expect(rateLimitError).toBeTruthy();
    });

    it('should enforce rate limits on post creation', async () => {
      const testForumId = 'test-forum-id';
      let rateLimitError = null;
      
      // Try to create 20 posts rapidly
      for (let i = 0; i < 20; i++) {
        const { error } = await supabase
          .from('forum_posts')
          .insert({
            forum_id: testForumId,
            title: `Test post ${i}`,
            content: 'Test content',
          });
        
        if (error && error.message.includes('rate limit')) {
          rateLimitError = error;
          break;
        }
      }
      
      // Should hit rate limit (10 posts per hour)
      expect(rateLimitError).toBeTruthy();
    });

    it('should enforce rate limits on authentication', async () => {
      let rateLimitError = null;
      
      // Try to sign in 10 times with wrong password
      for (let i = 0; i < 10; i++) {
        const { error } = await supabase.auth.signInWithPassword({
          email: 'test@example.com',
          password: 'wrong-password',
        });
        
        if (error && error.message.includes('rate limit')) {
          rateLimitError = error;
          break;
        }
      }
      
      // Should hit rate limit after 5 attempts
      expect(rateLimitError).toBeTruthy();
    });
  });

  describe('CSRF Protection', () => {
    it('should require CSRF token for mutations', async () => {
      // Try to create post without CSRF token
      const { error } = await supabase
        .from('forum_posts')
        .insert({
          forum_id: 'test-forum',
          title: 'Test',
          content: 'Test',
        });
      
      // Should fail if CSRF protection is enforced
      // Note: Supabase doesn't have built-in CSRF, implement in edge functions
      expect(error).toBeTruthy();
    });
  });

  describe('Content Security Policy (CSP) Tests', () => {
    it('should block inline scripts', () => {
      // Check if CSP headers are set
      const cspHeader = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
      
      if (cspHeader) {
        const cspContent = cspHeader.getAttribute('content');
        expect(cspContent).toContain("script-src 'self'");
        expect(cspContent).not.toContain("'unsafe-inline'");
      }
    });
  });

  describe('Password Security', () => {
    it('should reject weak passwords', async () => {
      const { error } = await supabase.auth.signUp({
        email: 'weak@example.com',
        password: '123', // Too short
      });
      
      expect(error).toBeTruthy();
    });

    it('should reject common passwords', async () => {
      const { error } = await supabase.auth.signUp({
        email: 'common@example.com',
        password: 'password', // Too common
      });
      
      expect(error).toBeTruthy();
    });

    it('should accept strong passwords', async () => {
      const { error } = await supabase.auth.signUp({
        email: 'strong@example.com',
        password: 'SecureP@ssw0rd123!',
      });
      
      // Should succeed or fail for non-password reasons
      if (error) {
        expect(error.message).not.toContain('password');
      }
    });
  });

  describe('Session Security', () => {
    it('should invalidate session after logout', async () => {
      // Sign in
      await supabase.auth.signInWithPassword({
        email: 'test@example.com',
        password: 'password',
      });
      
      // Sign out
      await supabase.auth.signOut();
      
      // Try to access protected resource
      const { data, error } = await supabase
        .from('user_interactions')
        .select('*')
        .limit(1);
      
      expect(error).toBeTruthy();
      expect(data).toBeNull();
    });

    it('should refresh expired tokens', async () => {
      const { data: { session } } = await supabase.auth.getSession();
      
      if (session) {
        // Force token refresh
        const { error } = await supabase.auth.refreshSession();
        expect(error).toBeNull();
      }
    });
  });

  describe('File Upload Security', () => {
    it('should reject executable files', () => {
      const maliciousFile = new File(['content'], 'malware.exe', {
        type: 'application/x-msdownload',
      });
      
      // Should be rejected by validation
      const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
      const isAllowed = allowedTypes.includes(maliciousFile.type);
      
      expect(isAllowed).toBe(false);
    });

    it('should reject oversized files', () => {
      // 10MB file
      const largeContent = new Array(10 * 1024 * 1024).fill('x').join('');
      const largeFile = new File([largeContent], 'large.jpg', {
        type: 'image/jpeg',
      });
      
      // Should be rejected if limit is 5MB
      const maxSizeBytes = 5 * 1024 * 1024;
      expect(largeFile.size).toBeGreaterThan(maxSizeBytes);
    });
  });

  describe('API Endpoint Security', () => {
    it('should validate input types', async () => {
      // Try to send wrong type for user_id (should be UUID)
      const { error } = await supabase
        .rpc('toggle_like', {
          p_user_id: 'not-a-uuid',
          p_track_id: 'track123',
        });
      
      expect(error).toBeTruthy();
    });

    it('should handle null values safely', async () => {
      const { error } = await supabase
        .rpc('toggle_like', {
          p_user_id: null,
          p_track_id: null,
        });
      
      expect(error).toBeTruthy();
    });
  });
});

/**
 * AUTOMATED PENETRATION TESTING SCRIPT
 * Run this to execute all security tests
 */
export async function runPenetrationTests() {
  console.log('ðŸ”’ Starting Penetration Testing Suite...\n');
  
  const results = {
    xss: 0,
    sqlInjection: 0,
    authBypass: 0,
    rateLimit: 0,
    csrf: 0,
    total: 0,
  };
  
  // Run tests and collect results
  // This would integrate with your test runner
  
  console.log('âœ… Penetration Testing Complete\n');
  console.log('Results:');
  console.log(`  XSS Prevention: ${results.xss} passed`);
  console.log(`  SQL Injection: ${results.sqlInjection} passed`);
  console.log(`  Auth Bypass: ${results.authBypass} passed`);
  console.log(`  Rate Limiting: ${results.rateLimit} passed`);
  console.log(`  CSRF Protection: ${results.csrf} passed`);
  console.log(`\n  Total: ${results.total} tests passed`);
  
  return results;
}
